% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/main_BASOFR.R
\name{fitBASOFR}
\alias{fitBASOFR}
\title{fit a BASOFR Model}
\usage{
fitBASOFR(
  y,
  X,
  t.grid,
  z = NULL,
  S = 10000,
  burnin = 10000,
  num_knots = NULL,
  boundary_reg = TRUE,
  save = FALSE,
  save_file = NULL,
  boundary_prior = c(0.01, 0.01),
  z_prior = c(0.01, 0.01),
  sigma2_prior = c(0.01, 0.01),
  plot_basisExpansionX = FALSE
)
}
\arguments{
\item{y}{A nx1 matrix or an array of the response variable.}

\item{X}{A list of matrices, each of dimension n x length(t.grid), representing observations of functional covariates. Missing values in the rows of X are allowed.}

\item{t.grid}{A numeric vector of the discrete points at which the functions X are observed.}

\item{z}{(Optional) A matrix of scalar covariates. Default is NULL. Note that we do not do any scaling or centering to preprocess this matrix. Therefore, it is advised that any necessary preprocessing, such as normalization or standardization, is performed on this matrix before passing it as an argument.}

\item{S}{An integer representing the number of iterations in the MCMC process. Default is 10000.}

\item{burnin}{An integer representing the number of initial iterations to discard (the "burn-in" period). Default is 10000.}

\item{num_knots}{(Optional) Number of knots for the B-spline basis. Default depends on the number of observations.}

\item{boundary_reg}{A logical flag indicating whether to implement boundary regularization for the regression function betas. Default is TRUE.}

\item{save}{(Optional) Boolean to decide whether to save the MCMC samples. Default is FALSE.}

\item{save_file}{(Optional) File name to save the MCMC samples. Default is NULL.}

\item{boundary_prior}{(Optional) A vector of length two representing the Inverse-Gamma prior parameters for the boundary basis coefficients variance. The first one is the shape parameter, and the second one is the rate parameter. Default is c(0.01, 0.01).}

\item{z_prior}{(Optional) A vector of length two representing the Inverse-Gamma prior parameters for the variance of the z-variables. The first one is the shape parameter, and the second one is the rate parameter. Default is c(0.01, 0.01).}

\item{sigma2_prior}{(Optional) A vector of length two representing the Inverse-Gamma prior parameters for the variance of the error term. The first element is the shape parameter, and the second is the rate parameter. Default is c(0.01, 0.01).}

\item{plot_basisExpansionX}{(Optional) Boolean to decide whether to plot the basis expansion of X. Default is FALSE. The B-spline basis selected by default typically captures the trend of the functional covariates while smoothing out irregular features. However, when the BASOFR model does not yield satisfactory results, it may be beneficial to examine the basis expansion of X by setting this parameter to TRUE. For each unique domain in the X covariates, a random observation is selected and the basis expansion for all functional covariates (where the coefficients are derived from ordinary least squares estimates) is displayed. If the B-spline basis expansion fails to adequately represent the original functional observations, consider increasing the number of knots of the B-spline using the \code{num_knots} argument. Conversely, if the B-spline basis expansion appears to overfit the original functional observations, consider decreasing the number of knots of the B-spline using the \code{num_knots} argument.}
}
\value{
Returns a list containing the following components:
\itemize{
\item{beta.post:}{An array of dimension p x S x length(t.grid), containing the posterior draws of the functional regression coefficients, where p is the number of functional covariates.}
\item{intercept_post:}{A length S vector of posterior draws of the intercept term.}
\item{Alpha.post:}{If z is not NULL, a S x p_scalar matrix of posterior draws of the scalar regression coefficients, where p_scalar is the number of scalar covariates.}
\item{sigma.2.post:}{A S x 1 array of posterior draws of the error term variance.}
\item{beta.post.mean:}{A p x length(t.grid) matrix, containing the posterior mean of the functional regression coefficients.}
\item{beta.95CI:}{An array of dimension p x length(t.grid) x 2, containing the 95\% posterior credible interval of the functional regression coefficients.}
\item{beta.50CI:}{An array of dimension p x length(t.grid) x 2, containing the 50\% posterior credible interval of the functional regression coefficients.}
\item{t.grid:}{A vector of discrete points where the functional regression coefficients are estimated on. Same as the argument t.grid.}
\item{other_parameters:}{A list containing the following components:
\itemize{
\item{DHS.post:}{A list containing the posterior draws of the DHS mu, phi, lambda terms}
\item{B.post:}{An array of dimension p x S x K containing the posterior draws of the B-spline basis coefficients of the functional regression coefficients, where K is the dimension of the B-spline basis we used to expand the regression functions and the functional covariates.}
\item{z.sigma.2.post:}{If z is not NULL, a S x p_scalar matrix containing the posterior draws of the variance of the scalar regression coefficients.}}}
}
}
\description{
This function fits a Bayesian Adaptive Scalar-on-Function Regression (BASOFR) model
using a Gibbs sampler.
}
\examples{
\dontrun{
# Simulate data for BASOFR
data = simulate_SOFR(n = 1500, p = 3, SNR = 5, num_z_continuous = 5, num_z_dummy = 2,
                     beta_types = c('spiky','smooth','stepwise'), domain_X = c(0, 1),
                     max_obs = 105,
                     subject_specific_domain = TRUE)

# Scale the continuous z-variables to have std 1 and mean 0, and create the z-variables matrix
z = cbind(scale(data$Z_continuous), data$Z_dummy)

# Store original means and standard deviations of z-variables for later use
z_continuous_means = colMeans(data$Z_continuous, na.rm = TRUE)
z_continuous_sds = apply(data$Z_continuous, 2, sd, na.rm = TRUE)

# Fit the BASOFR model
BASOFR_fit <- fitBASOFR(y = data$y, X = data$X, t.grid = data$t.grid, z = z,
                        S = 1000, burnin = 1000)

# Examine the items in the BASOFR_fit
str(BASOFR_fit)

# Obtain the ground truth beta
groundTruth = matrix(unlist(data$groundTruth$beta), byrow=TRUE, nrow=3)

# Plot the fit of the BASOFR model
plot_BASOFR_fit(BASOFR_fit, groundTruth)
}
}
